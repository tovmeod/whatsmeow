import asyncio
import logging

import aiohttp
import yaml
from aiohttp import WSMsgType, web

logger = logging.getLogger(__name__)


class ReplayMismatchError(AssertionError):
    """Raised during strict replay if a client interaction deviates from the recording."""

    pass


class WebSocketProxy:
    """
    Proxies WebSocket communication between a client and a target server,
    recording all interactions (messages and close events) with timestamps.
    """

    def __init__(self, target_url):
        self.target_url = target_url
        self.recorded_interactions = []

    async def proxy_connection(self, client_ws):
        """
        Establishes a proxy connection. Connects to the target WebSocket server
        and relays messages between the client and the server.
        """
        session = aiohttp.ClientSession()

        try:
            # Connect to the real target server
            logger.info(f"Connecting to target server: {self.target_url}")
            async with session.ws_connect(self.target_url) as server_ws:
                logger.info("Connected to target server, starting proxy relay")

                # Create tasks for both directions
                client_to_server_task = asyncio.create_task(
                    self._relay_messages(client_ws, server_ws, "client_to_server")
                )
                server_to_client_task = asyncio.create_task(
                    self._relay_messages(server_ws, client_ws, "server_to_client")
                )

                # Wait for either direction to close
                done, pending = await asyncio.wait(
                    [client_to_server_task, server_to_client_task], return_when=asyncio.FIRST_COMPLETED
                )

                # Cancel remaining tasks
                for task in pending:
                    task.cancel()

        except Exception as e:
            logger.error(f"Proxy connection failed: {e}")
            raise
        finally:
            await session.close()

    async def _relay_messages(self, from_ws, to_ws, direction):
        """Relay messages from one WebSocket to another while recording."""
        try:
            async for msg in from_ws:
                if msg.type == WSMsgType.TEXT:
                    await to_ws.send_str(msg.data)
                    self._record_message(direction, "text", msg.data)
                elif msg.type == WSMsgType.BINARY:
                    await to_ws.send_bytes(msg.data)
                    self._record_message(direction, "binary", msg.data.hex())
                elif msg.type == WSMsgType.CLOSE:
                    await to_ws.close()
                    self._record_message(direction, "close", None)
                    break
                elif msg.type == WSMsgType.ERROR:
                    logger.error(f"WebSocket error in {direction}: {msg.data}")
                    break
        except Exception as e:
            logger.error(f"Error in {direction} relay: {e}")

    def _record_message(self, direction, msg_type, payload):
        """
        Record a single message interaction with its direction, type, payload,
        and a timestamp generated by `asyncio.get_event_loop().time()`.
        """
        interaction = {
            "timestamp": asyncio.get_event_loop().time(),  # Timestamp the interaction
            "direction": direction,  # "client_to_server" or "server_to_client"
            "type": msg_type,
            "payload": payload,
        }
        self.recorded_interactions.append(interaction)
        logger.debug(f"Recorded {direction} {msg_type} message")


async def create_ws_server_from_cassette(cassette_file, port, *, record=False, strict_replay=False):
    """
    Create WebSocket server that can either:
    1. Replay recorded interactions from a cassette file (normal mode).
       Interactions are processed from a unified timeline, and server messages
       are replayed with delays based on recorded timestamps.
    2. Act as a proxy to a real WebSocket server while recording all interactions
       to a cassette file (record mode).

    Args:
        cassette_file (pathlib.Path): Path to the YAML cassette file.
        port (int): Port to run the VCR server on.
        record (bool, optional): If True, forces record mode. Defaults to False.
            If False and cassette_file does not exist, record mode is also enabled.
        strict_replay (bool, optional): If True during playback mode, enables strict
            validation of client messages against the recording. Any deviation
            (type, payload, or unexpected close/error) will raise a
            `ReplayMismatchError`. Defaults to False.
    """

    # Determine recording mode automatically if no cassette exists or record=True
    should_record = record or not cassette_file.exists()

    if cassette_file.exists() and not should_record:
        # Load existing cassette for playback
        with cassette_file.open("r") as f:
            cassette = yaml.safe_load(f)
        interactions = cassette.get("interactions", [])
        logger.info(f"Loaded {len(interactions)} interactions from {cassette_file}")
    else:
        # Recording mode or no existing cassette
        interactions = []
        cassette = {"interactions": []}
        logger.info(f"Recording mode: will create new cassette at {cassette_file}")

    # For recording mode, get target URL from FrameSocket
    target_url = None
    proxy = None
    if should_record:
        from pymeow.socket.framesocket import FrameSocket

        target_url = FrameSocket.url
        proxy = WebSocketProxy(target_url)
        logger.info(f"Auto-detected target URL from FrameSocket: {target_url}")

    async def handler(request):
        ws = web.WebSocketResponse()
        await ws.prepare(request)

        if should_record and proxy:
            # Proxy mode: relay to real server while recording
            logger.info(f"Recording mode: proxying to {target_url}")
            try:
                await proxy.proxy_connection(ws)
            except Exception as e:
                logger.error(f"Proxy connection failed: {e}")
                # Close the client connection
                if not ws.closed:
                    await ws.close()
        else:
            # Playback mode: replay recorded interactions
            logger.info(f"Playback mode: using {len(interactions)} recorded interactions, strict={strict_replay}")
            await _replay_interactions(ws, interactions, strict_replay)  # Pass the new parameter

        return ws

    async def _replay_interactions(ws, interactions, strict_replay=False):
        """
        Replays recorded WebSocket interactions with a client from a single,
        chronologically sorted list of interactions.

        Server-to-client messages are sent with delays derived from the
        original recorded timestamps to simulate realistic timing. Client-to-server
        messages are expected from the client in the recorded order.

        Args:
            ws (aiohttp.web.WebSocketResponse): The client WebSocket connection.
            interactions (list): A list of interaction dicts, sorted by timestamp.
            strict_replay (bool): If True, enables strict validation of client
                messages (type and payload) and actions (e.g., close).
                A `ReplayMismatchError` is raised on any deviation. If False,
                mismatches are logged as warnings.
        """
        logger.info(f"Starting replay of {len(interactions)} interactions (strict={strict_replay}).")
        last_timestamp = None
        if interactions:
            # Initialize last_timestamp with the timestamp of the first interaction.
            # This is used to calculate delays between subsequent interactions.
            last_timestamp = interactions[0].get("timestamp", asyncio.get_event_loop().time())

        try:
            for i, interaction in enumerate(interactions):
                current_timestamp = interaction["timestamp"]  # Timestamp of the current interaction
                if i > 0 and last_timestamp is not None:
                    # Calculate delay based on the difference from the previous interaction's timestamp.
                    # This simulates the original timing of messages.
                    delay = current_timestamp - last_timestamp
                    if delay > 0:
                        logger.debug(f"Sleeping for {delay:.4f}s before interaction {i}")
                        await asyncio.sleep(delay)
                last_timestamp = current_timestamp  # Update last_timestamp for the next iteration

                direction = interaction["direction"]
                msg_type = interaction["type"]
                payload = interaction["payload"]

                if ws.closed:
                    logger.warning(f"Client WebSocket closed during replay at interaction {i}, stopping.")
                    break

                if direction == "server_to_client":
                    logger.debug(f"Replaying server message {i}: type={msg_type}")
                    if msg_type == "text":
                        await ws.send_str(payload)
                    elif msg_type == "binary":
                        try:
                            await ws.send_bytes(bytes.fromhex(payload))
                        except ValueError as e:
                            logger.error(f"Error converting hex to bytes: {e}, payload: {payload[:50]}...")
                            # Continue with the next interaction instead of failing
                            continue
                    elif msg_type == "close":
                        logger.info("Replaying server close message.")
                        if not ws.closed:
                            await ws.close()
                        return  # End of interactions from server side

                elif direction == "client_to_server":
                    expected_msg_type_from_recording = msg_type
                    expected_payload_from_recording = payload
                    logger.debug(
                        f"Expecting client message {i}: type={expected_msg_type_from_recording}, "
                        f"payload={expected_payload_from_recording if len(str(expected_payload_from_recording)) < 50 else str(expected_payload_from_recording)[:50] + '...'}"
                    )
                    try:
                        # Expect a message from the client
                        # TODO: Consider making timeout configurable or part of cassette metadata
                        msg_from_client = await ws.receive(timeout=10)

                        match = False
                        actual_msg_type_str = ""  # String representation of actual message type
                        error_payload = None  # Actual payload received, for error reporting

                        if msg_from_client.type == WSMsgType.TEXT:
                            actual_msg_type_str = "TEXT"
                            error_payload = msg_from_client.data
                            if (
                                expected_msg_type_from_recording == "text"
                                and expected_payload_from_recording == msg_from_client.data
                            ):
                                match = True
                                logger.debug(f"Client message {i} (TEXT) matches recording.")
                        elif msg_from_client.type == WSMsgType.BINARY:
                            actual_msg_type_str = "BINARY"
                            error_payload = msg_from_client.data.hex()
                            if (
                                expected_msg_type_from_recording == "binary"
                                and expected_payload_from_recording == msg_from_client.data.hex()
                            ):
                                match = True
                                logger.debug(f"Client message {i} (BINARY) matches recording.")
                        elif msg_from_client.type == WSMsgType.CLOSE:
                            actual_msg_type_str = "CLOSE"
                            # Payload for close is None or not applicable for matching in this context.
                            error_payload = "Connection closed by client"  # Descriptive payload for error message
                            if expected_msg_type_from_recording == "close":
                                match = True
                                logger.debug(f"Client close message {i} was expected and received.")
                            # Further handling for CLOSE (e.g., breaking loop) is done after the main mismatch check.
                        elif msg_from_client.type == WSMsgType.ERROR:
                            actual_msg_type_str = "ERROR"
                            error_payload = str(ws.exception())  # Get exception associated with the error
                            logger.error(f"Client WebSocket error during replay at interaction {i}: {error_payload}")
                            # Errors from the client are generally treated as mismatches if not specifically expected.
                            # Further handling for ERROR is done after the main mismatch check.
                        else:
                            # Handle other unexpected WSMsgTypes (e.g., PING, PONG if not filtered by receive())
                            actual_msg_type_str = msg_from_client.type.name
                            error_payload = msg_from_client.data if msg_from_client.data else ""

                        if not match:
                            # This block is entered if:
                            # 1. The received message type/payload did not match the expected recording.
                            # 2. The client sent an WSMsgType that was not expected (e.g., TEXT when BINARY was recorded).
                            error_msg = (
                                f"Client message {i} mismatch. "
                                f"Expected: type={expected_msg_type_from_recording}, payload={expected_payload_from_recording}. "
                                f"Got: type={actual_msg_type_str}, payload={error_payload}"
                            )
                            if strict_replay:
                                raise ReplayMismatchError(error_msg)
                            else:
                                logger.warning(error_msg)

                        # Handle connection termination states (CLOSE, ERROR) after the main mismatch check.
                        if msg_from_client.type == WSMsgType.CLOSE:
                            logger.info(
                                f"Client closed WebSocket connection at interaction {i} (expected_was_close={expected_msg_type_from_recording == 'close'})."
                            )
                            # If this close was unexpected and strict_replay is on, ReplayMismatchError was already raised by the '!match' block.
                            # If not strict, a warning was logged.

                            # Instead of stopping the replay, we'll continue with server-to-client messages
                            # This allows tests to proceed even if the client closes the connection unexpectedly
                            # during the handshake process
                            logger.warning(
                                "Client closed connection unexpectedly. Continuing with server-to-client messages only."
                            )

                            # Skip to the next server-to-client message
                            continue_from_index = i + 1
                            remaining_server_messages = [
                                (j, interaction)
                                for j, interaction in enumerate(interactions[continue_from_index:], continue_from_index)
                                if interaction["direction"] == "server_to_client"
                            ]

                            # For handshake-related closures, we don't need to do anything special
                            # The client will handle the connection closure and emit a Disconnected event
                            # which will trigger the timeout event in the QR channel
                            if i < 3:  # Assuming handshake happens in the first few interactions
                                logger.info("Early connection closure detected, likely during handshake.")

                            if remaining_server_messages:
                                logger.info(
                                    f"Continuing with {len(remaining_server_messages)} remaining server-to-client messages"
                                )
                                for _, (interaction_index, interaction) in enumerate(remaining_server_messages):
                                    if ws.closed:
                                        logger.warning("WebSocket is closed, cannot send more messages")
                                        break

                                    msg_type = interaction["type"]
                                    payload = interaction["payload"]

                                    logger.debug(
                                        f"Replaying server message {interaction_index} (post-close): type={msg_type}"
                                    )
                                    try:
                                        if msg_type == "text":
                                            await ws.send_str(payload)
                                        elif msg_type == "binary":
                                            try:
                                                await ws.send_bytes(bytes.fromhex(payload))
                                            except ValueError as e:
                                                logger.error(
                                                    f"Error converting hex to bytes: {e}, payload: {payload[:50]}..."
                                                )
                                                continue
                                        elif msg_type == "close":
                                            logger.info("Replaying server close message.")
                                            if not ws.closed:
                                                await ws.close()
                                            break
                                    except Exception as e:
                                        logger.error(f"Error sending message after client close: {e}")
                                        break

                            return  # Stop normal replay as client connection is gone

                        if msg_from_client.type == WSMsgType.ERROR:
                            # Error was logged by the type check. If strict_replay and mismatch, ReplayMismatchError was raised.
                            logger.error(f"Client sent WebSocket error at interaction {i}. Stopping replay.")
                            return  # Stop replay on client error.

                    except asyncio.TimeoutError:
                        # Timeout occurred while waiting for the client to send a message.
                        error_msg = f"Timeout waiting for client message {i} (expected type={expected_msg_type_from_recording}, payload={expected_payload_from_recording})."
                        if strict_replay:
                            raise ReplayMismatchError(error_msg)
                        else:
                            logger.warning(error_msg)
                        break  # Stop replay as the expected client message was not received.
                    except ReplayMismatchError:
                        # Re-raise if it's our specific error, ensuring it propagates.
                        raise
                    except Exception as e:
                        # Catch other unexpected errors during ws.receive() or subsequent logic.
                        error_msg = f"Error receiving or processing client message {i} (expected type={expected_msg_type_from_recording}): {e}"
                        logger.error(error_msg)
                        if strict_replay:
                            # Treat other exceptions during client message handling as mismatches in strict mode.
                            raise ReplayMismatchError(error_msg) from e
                        break  # Stop replay on other exceptions in non-strict mode.
            logger.info("Finished replaying all interactions or connection closed.")

        except ReplayMismatchError as e:
            # This catches ReplayMismatchError raised from client_to_server handling.
            logger.error(f"ReplayMismatchError occurred: {e}")  # Log the specific mismatch error
            if not ws.closed:  # Attempt to close before re-raising
                await ws.close()
            raise  # Re-raise to be caught by test or higher-level handler.
        except Exception as e:
            logger.error(f"Unhandled error during replay of interactions: {e}")
            # Fallback for other unexpected errors, ensure ws is closed.
        finally:
            # Ensure the WebSocket is closed cleanly in all scenarios (successful replay, error, or mismatch).
            if not ws.closed:
                logger.info("Replay finished or errored, ensuring WebSocket is closed.")
                await ws.close()

    app = web.Application()
    app.router.add_get("/ws", handler)

    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "localhost", port)
    await site.start()

    logger.info(f"WebSocket VCR server started on ws://localhost:{port}/ws")

    async def shutdown():
        await runner.cleanup()

        if should_record and proxy and proxy.recorded_interactions:
            # Save recorded interactions
            cassette["interactions"] = proxy.recorded_interactions

            # Create directory if it doesn't exist
            cassette_file.parent.mkdir(parents=True, exist_ok=True)

            with cassette_file.open("w") as f:
                yaml.safe_dump(cassette, f, sort_keys=False, default_flow_style=False)

            logger.info(f"Recorded {len(proxy.recorded_interactions)} interactions to {cassette_file}")

    return {
        "app": app,
        "runner": runner,
        "site": site,
        "proxy": proxy,
        "recording": should_record,
        "target_url": target_url,
        "shutdown": shutdown,
    }
