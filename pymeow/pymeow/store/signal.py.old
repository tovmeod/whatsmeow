"""
Signal protocol store implementation for WhatsApp.

Port of whatsmeow/store/signal.go
"""
from typing import Optional, List, Any, Tuple
import logging

# Signal protocol imports
from signal_protocol import curve, identity_key, state, storage, address
from signal_protocol.state import PreKeyRecord, SessionRecord, SignedPreKeyRecord
from signal_protocol.sender_keys import SenderKeyRecord, SenderKeyName

# Internal imports - forward reference to avoid circular imports
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .store import Device

# Equivalent to Go's SignalProtobufSerializer = serialize.NewProtoBufSerializer()
# In Python, serialization is handled internally by the record classes
SignalProtobufSerializer = None

logger = logging.getLogger(__name__)


def get_identity_key_pair(device: 'Device') -> 'IdentityKeyPair':
    """
    Port of Go method GetIdentityKeyPair from Device.

    Returns the identity key pair for this device by creating a new KeyPair
    with the device's identity keys.

    Returns:
        IdentityKeyPair containing the device's public and private identity keys
    """
    # TODO: Review identity.KeyPair implementation
    # TODO: Review identity.Key implementation
    # TODO: Review ecc.DjbECPublicKey implementation
    # TODO: Review ecc.DjbECPrivateKey implementation

    from .identity import KeyPair, Key # this should be from libsignal
    from .ecc import DjbECPublicKey, DjbECPrivateKey # this should be from libsignal

    return KeyPair(
        Key(DjbECPublicKey(device.identity_key.pub)),
        DjbECPrivateKey(device.identity_key.priv)
    )


async def get_local_registration_id(device: 'Device') -> int:
    """
    Get the registration ID for this device.

    Go equivalent: func (device *Device) GetLocalRegistrationID() uint32
    """
    return device.registration_id


def save_identity(
    device: 'Device',
    address: 'ProtocolAddress',
    identity_key: 'IdentityKey'
) -> Optional[Exception]:
    """
    Port of Go method SaveIdentity from Device.

    Saves an identity key for the given address.

    Args:
        ctx: Context for the operation
        address: The protocol address to save identity for
        identity_key: The identity key to save

    Returns:
        None if successful, Exception if error occurred
    """
    # TODO: Review ProtocolAddress.string method implementation
    # TODO: Review IdentityKey.public_key method implementation
    # TODO: Review PublicKey.public_key method implementation
    # TODO: Review Identities.put_identity implementation

    try:
        addr_string = address.string()
        err = device.identities.put_identity(addr_string, identity_key.public_key().public_key())
        if err is not None:
            return Exception(f"failed to save identity of {addr_string}: {err}")
        return None
    except Exception as e:
        return Exception(f"failed to save identity of {address.string()}: {e}")


def is_trusted_identity(
    device: 'Device',
    address: 'ProtocolAddress',
    identity_key: 'IdentityKey'
) -> Tuple[bool, Optional[Exception]]:
    """
    Port of Go method IsTrustedIdentity from Device.

    Checks if an identity key is trusted for the given address.

    Args:
        device:
        address: The protocol address to check trust for
        identity_key: The identity key to verify trust for

    Returns:
        Tuple containing (is_trusted: bool, error: Optional[Exception])
    """
    # TODO: Review ProtocolAddress.string method implementation
    # TODO: Review IdentityKey.public_key method implementation
    # TODO: Review PublicKey.public_key method implementation
    # TODO: Review Identities.is_trusted_identity implementation

    addr_string = address.string()
    is_trusted, err = device.identities.is_trusted_identity(addr_string, identity_key.public_key().public_key())
    if err is not None:
        return False, Exception(f"failed to check if {addr_string}'s identity is trusted: {err}")
    return is_trusted, None


async def load_pre_key(
    device: 'Device',
    id_: int
) -> Tuple[Optional['PreKey'], Optional[Exception]]:
    """
    Port of Go method LoadPreKey from Device.

    Loads a pre-key record by ID.

    Args:
        ctx: Context for the operation
        id_: The pre-key ID to load

    Returns:
        Tuple containing (pre_key: Optional[PreKey], error: Optional[Exception])
    """
    # TODO: Review PreKeys.get_pre_key implementation
    # TODO: Review PreKey record implementation
    # TODO: Review ecc.ECKeyPair implementation
    # TODO: Review ecc.DjbECPublicKey implementation
    # TODO: Review ecc.DjbECPrivateKey implementation

    pre_key, err = await device.pre_keys.get_pre_key(id_)
    if err is not None:
        return None, Exception(f"failed to load prekey {id_}: {err}")
    if pre_key is None:
        return None, None

    return PreKey(
        pre_key.key_id,
        ECKeyPair(
            DjbECPublicKey(pre_key.pub),
            DjbECPrivateKey(pre_key.priv)
        ),
        None
    ), None


async def remove_pre_key(
    device: 'Device',
    id_: int
) -> Optional[Exception]:
    """
        Port of Go method RemovePreKey from Device.

        Removes a pre-key by ID.

        Args:
            ctx: Context for the operation
            id_: The pre-key ID to remove

        Returns:
            None if successful, Exception if error occurred
        """
    # TODO: Review PreKeys.remove_pre_key implementation
    err = await device.pre_keys.remove_pre_key(id_)
    if err is not None:
        return Exception(f"failed to remove prekey {id_}: {err}")
    return None


async def store_pre_key(device: 'Device', ctx: Any, pre_key_id: int, pre_key_record: PreKeyRecord) -> None:
    """
    Store a pre-key.

    Go equivalent: panic("not implemented") - this is not implemented in Go either
    """
    raise NotImplementedError("store_pre_key is not implemented")


async def contains_pre_key(device: 'Device', ctx: Any, pre_key_id: int) -> bool:
    """
    Check if a pre-key exists.

    Go equivalent: panic("not implemented") - this is not implemented in Go either
    """
    raise NotImplementedError("contains_pre_key is not implemented")


# SessionStore implementation
async def load_session(
    device: 'Device',
    address: address.ProtocolAddress
) -> Tuple[Optional[SessionRecord], Optional[Exception]]:
    """
        Port of Go method LoadSession from Device.

        Loads a session record for the given address.

        Args:
            device: Context for the operation
            address: The protocol address to load session for

        Returns:
            Tuple containing (session: Optional[Session], error: Optional[Exception])
        """
    # TODO: Review ProtocolAddress.string method implementation
    # TODO: Review Sessions.get_session implementation
    # TODO: Review Session record implementation
    # TODO: Review SignalProtobufSerializer implementation
    # TODO: Review Session.new_session implementation
    # TODO: Review Session.new_session_from_bytes implementation
    addr_string = address.string()

    raw_sess, err = await device.sessions.get_session(addr_string)
    if err is not None:
        return None, Exception(f"failed to load session with {addr_string}: {err}")
    if raw_sess is None:
        # return SessionRecord.new()
        return SessionRecord.new_session(
            SignalProtobufSerializer.session,
            SignalProtobufSerializer.state
        ), None

    # Deserialize the existing session record from bytes
    # In Go: record.NewSessionFromBytes(rawSess, SignalProtobufSerializer.Session, SignalProtobufSerializer.State)
    # return SessionRecord.deserialize(raw_sess)
    sess, err = SessionRecord.new_session_from_bytes(
        raw_sess,
        SignalProtobufSerializer.session,
        SignalProtobufSerializer.state
    )
    if err is not None:
        return None, Exception(f"failed to deserialize session with {addr_string}: {err}")
    return sess, None


async def get_sub_device_sessions(device: 'Device', ctx: Any, name: str) -> list[int]:
    """
    Get all sub-device sessions for a name.

    Go equivalent: panic("not implemented") - this is not implemented in Go either
    """
    raise NotImplementedError("get_sub_device_sessions is not implemented")


async def store_session(
    device: 'Device',
    address: address.ProtocolAddress,
    record: SessionRecord
) -> Optional[Exception]:
    """
        Port of Go method StoreSession from Device.

        Stores a session record for the given address.

        Args:
            ctx: Context for the operation
            address: The protocol address to store session for
            record: The session record to store

        Returns:
            None if successful, Exception if error occurred
        """
    # TODO: Review ProtocolAddress.string method implementation
    # TODO: Review Sessions.put_session implementation
    # TODO: Review Session.serialize method implementation
    addr_string = address.string()
    err = await device.sessions.put_session(addr_string, record.serialize())
    if err is not None:
        return Exception(f"failed to store session with {addr_string}: {err}")
    return None

async def contains_session(
    device: 'Device',
    remote_address: address.ProtocolAddress
) -> bool:
    """
    Port of Go method ContainsSession from Device.

    Checks if a session exists for the given remote address.

    Args:
        device:
        remote_address: The remote protocol address to check

    Returns:
        has_session: bool
    Raises:
        Exception
    """
    # TODO: Review ProtocolAddress.string method implementation
    # TODO: Review Sessions.has_session implementation

    has_session = await device.sessions.has_session(str(remote_address))
    return has_session


async def delete_session(device: 'Device', ctx: Any, remote_address: address.ProtocolAddress) -> None:
    """
    Delete a session for a remote address.

    Go equivalent: panic("not implemented") - this is not implemented in Go either
    """
    raise NotImplementedError("delete_session is not implemented")


async def delete_all_sessions(device: 'Device', ctx: Any) -> None:
    """
    Delete all sessions.

    Go equivalent: panic("not implemented") - this is not implemented in Go either
    """
    raise NotImplementedError("delete_all_sessions is not implemented")


# SignedPreKeyStore implementation
def load_signed_pre_key(
    device: 'Device',
    signed_pre_key_id: int
) -> Tuple[Optional[SignedPreKeyRecord], Optional[Exception]]:
    """
    Port of Go method LoadSignedPreKey from Device.

    Loads a signed pre-key by ID. Returns the device's signed pre-key if the ID matches,
    otherwise returns None.

    Args:
        device: The device instance
        ctx: Context for the operation
        signed_pre_key_id: The signed pre-key ID to load

    Returns:
        Tuple containing (signed_pre_key: Optional[SignedPreKeyRecord], error: Optional[Exception])
    """
    # TODO: Review SignedPreKeyRecord implementation
    # TODO: Review ECKeyPair implementation
    # TODO: Review DjbECPublicKey implementation
    # TODO: Review DjbECPrivateKey implementation
    # TODO: Review SignedPreKeyRecord.new_signed_pre_key implementation

    from .record import SignedPreKeyRecord
    from .ecc import ECKeyPair, DjbECPublicKey, DjbECPrivateKey

    if signed_pre_key_id == device.signed_pre_key.key_id:
        return SignedPreKeyRecord.new_signed_pre_key(
            signed_pre_key_id,
            0,
            ECKeyPair.new_ec_key_pair(
                DjbECPublicKey.new_djb_ec_public_key(device.signed_pre_key.pub),
                DjbECPrivateKey.new_djb_ec_private_key(device.signed_pre_key.priv),
            ),
            device.signed_pre_key.signature,
            None
        ), None
    return None, None


async def load_signed_pre_keys(device: 'Device', ctx: Any) -> list[SignedPreKeyRecord]:
    """
    Load all signed pre-keys.

    Go equivalent: panic("not implemented") - this is not implemented in Go either
    """
    raise NotImplementedError("load_signed_pre_keys is not implemented")


async def store_signed_pre_key(device: 'Device', ctx: Any, signed_pre_key_id: int, record: SignedPreKeyRecord) -> None:
    """
    Store a signed pre-key.

    Go equivalent: panic("not implemented") - this is not implemented in Go either
    """
    raise NotImplementedError("store_signed_pre_key is not implemented")


async def contains_signed_pre_key(device: 'Device', ctx: Any, signed_pre_key_id: int) -> bool:
    """
    Check if a signed pre-key exists.

    Go equivalent: panic("not implemented") - this is not implemented in Go either
    """
    raise NotImplementedError("contains_signed_pre_key is not implemented")


async def remove_signed_pre_key(device: 'Device', ctx: Any, signed_pre_key_id: int) -> None:
    """
    Remove a signed pre-key.

    Go equivalent: panic("not implemented") - this is not implemented in Go either
    """
    raise NotImplementedError("remove_signed_pre_key is not implemented")


async def store_sender_key(
    device: 'Device',
    sender_key_name: SenderKeyName,
    key_record: SenderKeyRecord
) -> Optional[Exception]:
    """
    Port of Go method StoreSenderKey from Device.

    Stores a sender key for the given sender key name and group.

    Args:
        device: The device instance
        sender_key_name: The sender key name containing group ID and sender info
        key_record: The sender key record to store

    Returns:
        None if successful, Exception if error occurred
    """
    # TODO: Review SenderKeyName.group_id method implementation
    # TODO: Review SenderKeyName.sender method implementation
    # TODO: Review SenderKeyName.sender.string method implementation
    # TODO: Review SenderKeys.put_sender_key implementation
    # TODO: Review SenderKeyRecord.serialize implementation

    group_id = sender_key_name.group_id()
    sender_string = sender_key_name.sender().string()

    err = await device.sender_keys.put_sender_key(group_id, sender_string, key_record.serialize())
    if err is not None:
        return Exception(f"failed to store sender key from {sender_string} for {group_id}: {err}")
    return None


async def load_sender_key(
    device: 'Device',
    sender_key_name: SenderKeyName
) -> Tuple[Optional[SenderKeyRecord], Optional[Exception]]:
    """
    Port of Go method LoadSenderKey from Device.

    Loads a sender key for the given sender key name and group. Creates a new empty
    sender key if none exists, or deserializes an existing one from storage.

    Args:
        device: The device instance
        sender_key_name: The sender key name containing group ID and sender info

    Returns:
        Tuple containing (sender_key: Optional[SenderKeyRecord], error: Optional[Exception])
    """
    # TODO: Review SenderKeyName.group_id method implementation
    # TODO: Review SenderKeyName.sender method implementation
    # TODO: Review SenderKeyName.sender.string method implementation
    # TODO: Review SenderKeys.get_sender_key implementation
    # TODO: Review SenderKeyRecord.new_sender_key implementation
    # TODO: Review SenderKeyRecord.new_sender_key_from_bytes implementation
    # TODO: Review SignalProtobufSerializer implementation

    from .group_record import SenderKeyRecord
    from .serializer import SignalProtobufSerializer

    group_id = sender_key_name.group_id()
    sender_string = sender_key_name.sender().string()

    raw_key, err = await device.sender_keys.get_sender_key(group_id, sender_string)
    if err is not None:
        return None, Exception(f"failed to load sender key from {sender_string} for {group_id}: {err}")

    if raw_key is None:
        return SenderKeyRecord.new_sender_key(
            SignalProtobufSerializer.SENDER_KEY_RECORD,
            SignalProtobufSerializer.SENDER_KEY_STATE
        ), None

    key, err = SenderKeyRecord.new_sender_key_from_bytes(
        raw_key,
        SignalProtobufSerializer.SENDER_KEY_RECORD,
        SignalProtobufSerializer.SENDER_KEY_STATE
    )
    if err is not None:
        return None, Exception(f"failed to deserialize sender key from {sender_string} for {group_id}: {err}")

    return key, None

